<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI 페어 프로그래밍 가이드 2025</title>
    
    <link rel="preconnect" href="https://cdn.jsdelivr.net">
    <link href="https://cdn.jsdelivr.net/gh/orioncactus/pretendard/dist/web/static/pretendard.css" rel="stylesheet">
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-primary: #1e1b18;
            --bg-secondary: #2a2520;
            --bg-sidebar: #16130f;
            --text-primary: #f5f0e8;
            --text-secondary: #d4cec3;
            --text-muted: #b0a79a;
            --accent: #e8b878;
            --accent-secondary: #d4a574;
            --border: #4a443d;
            --sidebar-width: 240px;
        }

        body {
            font-family: 'Pretendard', -apple-system, BlinkMacSystemFont, system-ui, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.8;
            font-size: 16px;
        }

        .container {
            display: flex;
            min-height: 100vh;
        }

        .sidebar {
            width: var(--sidebar-width);
            background: var(--bg-sidebar);
            position: sticky;
            left: 0;
            top: 0;
            height: 100vh;
            overflow-y: auto;
            z-index: 1000;
            padding: 30px 0;
            border-right: 1px solid var(--border);
        }

        .sidebar-header {
            padding: 0 20px 20px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .sidebar-title {
            font-size: 16px;
            font-weight: 700;
            color: #f5f0e8;
            margin-bottom: 6px;
        }

        .sidebar-subtitle {
            font-size: 11px;
            color: rgba(255, 255, 255, 0.7);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .nav-section {
            padding: 16px 0;
        }

        .nav-section-title {
            padding: 8px 20px;
            font-size: 10px;
            font-weight: 700;
            color: rgba(255, 255, 255, 0.5);
            text-transform: uppercase;
            letter-spacing: 1.2px;
        }

        .nav-item {
            display: block;
            padding: 10px 20px;
            color: rgba(255, 255, 255, 0.8);
            text-decoration: none;
            font-size: 14px;
            transition: all 0.15s ease;
            border-left: 3px solid transparent;
        }

        .nav-item:hover {
            background: rgba(255, 255, 255, 0.08);
            color: #ffffff;
            border-left-color: var(--accent);
        }

        .nav-item.active {
            background: rgba(212, 165, 116, 0.15);
            color: var(--accent);
            border-left-color: var(--accent);
            font-weight: 600;
        }

        .main-content {
            flex: 1;
            padding: 60px 50px 100px;
            max-width: 900px;
            margin: 0 auto;
        }

        .document-header {
            margin-bottom: 60px;
            padding-bottom: 30px;
            border-bottom: 1px solid var(--border);
        }

        .document-title {
            font-size: 52px;
            font-weight: 900;
            color: var(--text-primary);
            margin-bottom: 16px;
            letter-spacing: -1px;
            line-height: 1.2;
        }

        .document-subtitle {
            font-size: 20px;
            color: var(--text-secondary);
            margin-bottom: 24px;
            line-height: 1.6;
        }

        .document-meta {
            font-size: 14px;
            color: var(--text-muted);
        }

        .section {
            margin-bottom: 80px;
            scroll-margin-top: 30px;
        }

        .section-number {
            font-size: 12px;
            font-weight: 700;
            color: var(--accent);
            text-transform: uppercase;
            letter-spacing: 1.5px;
            margin-bottom: 10px;
        }

        .section-title {
            font-size: 40px;
            font-weight: 800;
            color: var(--text-primary);
            margin-bottom: 16px;
            letter-spacing: -0.5px;
            line-height: 1.3;
        }

        .section-description {
            font-size: 18px;
            color: var(--text-secondary);
            line-height: 1.8;
            margin-bottom: 36px;
        }

        h3 {
            font-size: 28px;
            font-weight: 700;
            color: var(--text-primary);
            margin: 48px 0 20px;
            letter-spacing: -0.5px;
        }

        h4 {
            font-size: 20px;
            font-weight: 600;
            color: var(--text-primary);
            margin: 32px 0 14px;
        }

        p {
            margin-bottom: 18px;
            color: var(--text-secondary);
            font-size: 17px;
            line-height: 1.7;
        }

        ul, ol {
            margin: 20px 0 20px 28px;
            color: var(--text-secondary);
        }

        li {
            margin-bottom: 10px;
            padding-left: 6px;
            line-height: 1.6;
            font-size: 16px;
        }

        strong {
            color: var(--text-primary);
            font-weight: 600;
        }

        code {
            background: rgba(232, 184, 120, 0.1);
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Monaco', 'Courier New', monospace;
            font-size: 14px;
            color: var(--accent);
        }

        pre {
            background: var(--bg-secondary);
            padding: 20px;
            border-radius: 6px;
            overflow-x: auto;
            font-family: 'Monaco', 'Courier New', monospace;
            font-size: 14px;
            border: 1px solid var(--border);
            margin: 24px 0;
            line-height: 1.6;
        }

        .info-box {
            padding: 28px;
            margin: 32px 0;
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-left: 4px solid var(--accent);
            border-radius: 6px;
        }

        .info-box.success {
            border-left-color: #6b9b7a;
        }

        .info-box.warning {
            border-left-color: #d4883d;
        }

        .info-box.highlight {
            border-left-color: #5a8fb8;
        }

        .info-box h4 {
            font-size: 19px;
            margin: 0 0 16px;
        }

        .info-box p {
            font-size: 16px;
            margin-bottom: 14px;
        }

        .info-box ul, .info-box ol {
            margin: 14px 0 0 24px;
        }

        .info-box li {
            font-size: 16px;
            margin-bottom: 8px;
        }

        .comparison-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 24px;
            margin: 32px 0;
        }

        .comparison-item {
            padding: 28px;
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 6px;
        }

        .comparison-item h4 {
            font-size: 19px;
            margin: 0 0 16px;
        }

        .comparison-item p {
            font-size: 16px;
            margin-bottom: 14px;
        }

        .comparison-item ul {
            margin: 14px 0 0 24px;
        }

        .comparison-item li {
            font-size: 15px;
            margin-bottom: 7px;
        }

        .card-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
            margin: 32px 0;
        }

        .card {
            padding: 24px;
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 6px;
        }

        .card h4 {
            font-size: 18px;
            margin: 0 0 12px;
            color: var(--accent);
        }

        .card p {
            font-size: 15px;
            line-height: 1.6;
            margin-bottom: 0;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 32px 0;
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            font-size: 15px;
        }

        th {
            padding: 16px;
            text-align: left;
            font-weight: 600;
            color: var(--text-primary);
            background: rgba(232, 184, 120, 0.1);
            border-bottom: 2px solid var(--border);
            font-size: 16px;
        }

        td {
            padding: 16px;
            color: var(--text-secondary);
            border-bottom: 1px solid var(--border);
            font-size: 15px;
        }

        tr:last-child td {
            border-bottom: none;
        }

        .divider {
            height: 1px;
            background: var(--border);
            margin: 60px 0;
        }

        .highlight-stat {
            font-size: 42px;
            font-weight: 700;
            color: var(--accent);
            line-height: 1;
            margin: 10px 0;
        }

        .back-to-top {
            position: fixed;
            bottom: 40px;
            right: 40px;
            width: 50px;
            height: 50px;
            background: var(--accent);
            color: var(--bg-primary);
            border: none;
            border-radius: 50%;
            font-size: 24px;
            cursor: pointer;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
            z-index: 999;
        }

        .back-to-top.visible {
            opacity: 1;
            visibility: visible;
        }

        .back-to-top:hover {
            background: var(--accent-secondary);
            transform: translateY(-3px);
        }

        @media (max-width: 1024px) {
            .sidebar {
                transform: translateX(-100%);
                transition: transform 0.3s ease;
            }
            
            .sidebar.open {
                transform: translateX(0);
            }
            
            .main-content {
                margin-left: 0;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <aside class="sidebar" id="sidebar">
            <div class="sidebar-header">
                <div class="sidebar-title">AI 페어 프로그래밍</div>
                <div class="sidebar-subtitle">Complete Guide 2025</div>
            </div>
            
            <nav class="nav-section">
                <div class="nav-section-title">Introduction</div>
                <a href="#trend" class="nav-item">AI 업계 최신 트렌드</a>
                <a href="#background" class="nav-item">AI 기초 배경</a>
                <a href="#concept" class="nav-item">핵심 개념</a>
            </nav>
            
            <nav class="nav-section">
                <div class="nav-section-title">Foundation</div>
                <a href="#webdev" class="nav-item">웹/앱 개발 기초</a>
                <a href="#framework" class="nav-item">Model-Agent-Pilot</a>
            </nav>
            
            <nav class="nav-section">
                <div class="nav-section-title">Practice</div>
                <a href="#tools" class="nav-item">주요 AI 코딩 도구</a>
                <a href="#start" class="nav-item">시작하기</a>
                <a href="#handson" class="nav-item">실습: 삼체 시뮬레이터</a>
                <a href="#usage" class="nav-item">효과적으로 사용하기</a>
            </nav>
            
            <nav class="nav-section">
                <div class="nav-section-title">Perspective</div>
                <a href="#reality" class="nav-item">AI 코딩의 현실</a>
                <a href="#future" class="nav-item">미래 전망</a>
            </nav>
            
            <nav class="nav-section">
                <div class="nav-section-title">Resources</div>
                <a href="#learning" class="nav-item">학습 리소스</a>
            </nav>
        </aside>

        <main class="main-content">
            <header class="document-header">
                <h1 class="document-title">AI 페어 프로그래밍 가이드</h1>
                <p class="document-subtitle">Model, Agent, Pilot - AI 코딩의 3요소와 실전 활용법</p>
                <div class="document-meta">2025년 11월 업데이트 KIM HAKMIN</div>
            </header>

            <!-- Section: Trend -->
            <section id="trend" class="section">
                <div class="section-number">Introduction 01</div>
                <h2 class="section-title">AI 업계 최신 트렌드</h2>
                <p class="section-description">
                    3일 간격으로 "세계 최고 모델" 타이틀이 바뀌는 시대입니다.
                </p>

                <div style="text-align: center; margin: 30px 0;">
                    <img src="assets/llm_circle.jpg" alt="LLM 경쟁 구도" style="max-width: 100%; border-radius: 12px; box-shadow: 0 4px 20px rgba(0,0,0,0.1);">
                    <p style="font-size: 13px; color: var(--text-muted); margin-top: 12px;">AI 모델 경쟁의 순환 구조</p>
                </div>

                <p>2025년 11월, AI 업계는 역사상 가장 치열한 경쟁을 벌이고 있습니다. 11월 한 달만 GPT-5.1, Grok 4.1, Gemini 3가 연달아 출시되며 매주 "세계 최고" 타이틀이 바뀌었습니다.</p>

                <p><strong>11월의 전쟁: AI Autumn 2025</strong></p>
                <ul>
                    <li><strong>11월 13일:</strong> OpenAI GPT-5.1 & GPT-5.1-Codex 출시</li>
                    <li><strong>11월 17일:</strong> xAI Grok 4.1 - LMArena Text Arena 1위 탈환 (1483 Elo)</li>
                    <li><strong>11월 18일:</strong> Google Gemini 3 & Antigravity IDE 출시 - 종합 1위 (1501 Elo)</li>
                </ul>

                <p>단 6일 만에 세 개의 프론티어 모델이 연달아 출시된 것입니다. 이전에는 6개월 주기였던 출시가 이제는 일주일 주기로 바뀌었습니다.</p>

                <div class="info-box highlight">
                    <h4>2025년 11월 22일 현재 리더보드</h4>
                    
                    <p><strong>LMArena 종합 순위 (Text Arena)</strong></p>
                    <ul>
                        <li><strong>1위:</strong> Gemini 3 Pro - 1501 Elo</li>
                        <li><strong>2위:</strong> Grok 4.1 Thinking - 1483 Elo</li>
                        <li><strong>3위:</strong> Grok 4.1 (Fast) - 1465 Elo</li>
                        <li><strong>4위:</strong> Claude Sonnet 4.5 - 1445 Elo</li>
                    </ul>

                    <p style="margin-top: 18px;"><strong>코딩 특화 (SWE-bench Verified)</strong></p>
                    <ul>
                        <li><strong>1위:</strong> Claude Sonnet 4.5 - 77.2%</li>
                        <li><strong>2위:</strong> Gemini 3 Pro - 76.2%</li>
                        <li><strong>3위:</strong> GPT-5.1 - 74.9%</li>
                    </ul>

                    <p style="margin-top: 18px;"><strong>감성지능 (EQ-Bench3)</strong></p>
                    <ul>
                        <li><strong>1위:</strong> Grok 4.1 - 1586 Elo</li>
                        <li><strong>2위:</strong> Grok 4.1 Fast - 상위권</li>
                    </ul>

                    <p style="margin-top: 18px;"><strong>수학/추론 (AIME 2025)</strong></p>
                    <ul>
                        <li><strong>1위:</strong> Gemini 3 - 95% (툴 없음), 100% (툴 사용)</li>
                        <li><strong>2위:</strong> GPT-5 - 94.6%</li>
                    </ul>
                </div>

                <h3>코딩 분야: Claude가 여전히 최강</h3>

                <p>종합 순위에서는 Gemini 3가 1위지만, <strong>순수 코딩 작업</strong>에서는 여전히 <strong>Claude Sonnet 4.5</strong>가 최강입니다.</p>

                <div class="highlight-stat">77.2%</div>
                <p><strong>Claude Sonnet 4.5 SWE-bench Verified 점수 (2025년 9월)</strong></p>

                <ul>
                    <li>실제 GitHub 이슈 해결 능력 측정</li>
                    <li>30시간+ 장기 작업 가능</li>
                    <li>에러율: Sonnet 4 9% → Sonnet 4.5 0% (내부 벤치마크)</li>
                    <li>가격: $3/$15 (GPT 대비 3배 비쌈)</li>
                    <li>그럼에도 많은 개발자가 Claude 선택</li>
                </ul>

                <h3>상황별 최고 모델 (2025년 11월 기준)</h3>

                <div class="comparison-grid">
                    <div class="comparison-item">
                        <h4>코딩</h4>
                        <p><strong>1위:</strong> Claude Sonnet 4.5</p>
                        <p>SWE-bench, 장기 에이전트 작업, 코드 편집 정확도 최고</p>
                    </div>

                    <div class="comparison-item">
                        <h4>대화/감성지능</h4>
                        <p><strong>1위:</strong> Grok 4.1</p>
                        <p>EQ-Bench 1위, 창의적 글쓰기, 감정 인식 탁월</p>
                    </div>

                    <div class="comparison-item">
                        <h4>종합/추론</h4>
                        <p><strong>1위:</strong> Gemini 3</p>
                        <p>LMArena 1위, 수학/과학 최강, 멀티모달 통합</p>
                    </div>

                    <div class="comparison-item">
                        <h4>속도/비용</h4>
                        <p><strong>1위:</strong> GPT-5.1 Instant</p>
                        <p>적응형 추론, 빠른 응답, 합리적 가격 ($1.25/$10)</p>
                    </div>
                </div>

                <div class="info-box warning">
                    <h4>주의: 매주 바뀌는 순위</h4>
                    <p>AI 업계는 이제 주 단위로 역전이 일어나는 곳입니다:</p>
                    <ul>
                        <li>이번 달만 3개의 메이저 릴리스</li>
                        <li>각 모델마다 특화된 강점</li>
                        <li>벤치마크 1위가 실전 1위는 아님</li>
                        <li>용도에 맞는 모델 선택이 중요</li>
                    </ul>
                </div>

                <p>현재는 "어떤 모델이 최고인가"보다 "어떤 작업에 어떤 모델을 쓸 것인가"가 더 중요합니다. Gemini가 종합 1위지만 코딩은 Claude, 감성은 Grok, 비용은 GPT가 낫습니다.</p>
            </section>

            <div class="divider"></div>

            <!-- Section: Background -->
            <section id="background" class="section">
                <div class="section-number">Introduction 02</div>
                <h2 class="section-title">AI 기초: 알아야 할 배경</h2>
                <p class="section-description">
                    현재 AI 기술의 기반을 이해합니다.
                </p>

                <h3>Transformer: 모든 것의 시작</h3>

                <p><strong>Transformer</strong>는 2017년 Google이 발표한 딥러닝 아키텍처입니다. "Attention is All You Need" 논문에서 소개되었고, 현재 대부분의 대규모 언어 모델(LLM)의 기반이 되었습니다.</p>

                <div class="info-box">
                    <h4>핵심 메커니즘: Attention</h4>
                    <p>Attention은 문장의 각 단어가 다른 단어들과 어떤 관계를 가지는지 파악하는 메커니즘입니다.</p>
                    <ul>
                        <li>"강아지가 공을 물었다"에서 "물었다"의 주체가 "강아지"임을 파악</li>
                        <li>"배를 탔다"의 "배"는 탈것, "배가 아프다"의 "배"는 신체 부위로 구분</li>
                        <li>단어 간의 관계를 가중치로 학습</li>
                        <li>병렬 처리가 가능해 학습 속도 대폭 향상</li>
                    </ul>
                </div>

                <p>Transformer 이전의 RNN, LSTM은 순차적으로 처리해야 했기 때문에 느렸습니다. Transformer는 모든 단어를 동시에 처리할 수 있어 대규모 데이터 학습이 가능해졌습니다.</p>

                <h3>LLM의 발전</h3>

                <p>Transformer 아키텍처를 기반으로 대규모 언어 모델들이 등장했습니다.</p>

                <ul>
                    <li><strong>GPT 시리즈 (2018~)</strong>: OpenAI, 생성에 특화된 자기회귀 모델</li>
                    <li><strong>BERT (2018)</strong>: Google, 양방향 문맥 이해에 특화</li>
                    <li><strong>Claude (2023~)</strong>: Anthropic, 안전성과 장문 추론에 특화</li>
                    <li><strong>Gemini (2023~)</strong>: Google, 멀티모달 통합</li>
                </ul>

                <p>모두 Transformer 기반이지만, 학습 데이터, 학습 방법, 파라미터 수, 최적화 방향이 다릅니다.</p>

                <h3>코딩 AI의 특수성</h3>

                <p>코딩에 특화된 AI는 일반 LLM과 다른 특성이 있습니다.</p>

                <ul>
                    <li><strong>코드 데이터 학습</strong>: GitHub 등 공개 코드 저장소 대량 학습</li>
                    <li><strong>정확성 요구</strong>: 문법 오류나 로직 결함이 즉시 드러남</li>
                    <li><strong>컨텍스트 이해</strong>: 파일 간 관계, 프로젝트 구조, 의존성 파악</li>
                    <li><strong>도구 통합</strong>: 컴파일러, 린터, 테스트 프레임워크 실행</li>
                    <li><strong>실행 검증</strong>: 코드를 직접 실행해서 결과 확인</li>
                </ul>

                <p>이런 특성 때문에 코딩 AI는 일반 LLM을 파인튜닝하거나 특화된 도구를 추가합니다.</p>
            </section>

            <div class="divider"></div>

            <!-- Section: Concept -->
            <section id="concept" class="section">
                <div class="section-number">Introduction 03</div>
                <h2 class="section-title">핵심 개념 제대로 알기</h2>
                <p class="section-description">
                    AI 페어 프로그래밍에 필요한 정확한 용어를 배웁니다.
                </p>

                <h3>AI Agent란 무엇인가</h3>

                <p><strong>AI Agent</strong>를 제대로 이해하려면 다음 요소들을 살펴봐야 합니다. 실질적으로 유의미한 Agent라고 부르려면 보통 이런 5가지 능력을 요구합니다.</p>

                <div class="info-box highlight">
                    <h4>AI Agent의 5가지 핵심 능력</h4>
                    <p><strong>1. Planning (계획 수립)</strong></p>
                    <ul>
                        <li>복잡한 작업을 분석하고 단계별 계획 수립</li>
                    </ul>

                    <p><strong>2. Tool Use (도구 사용)</strong></p>
                    <ul>
                        <li>웹 검색, 파일 읽기/쓰기, API 호출 등</li>
                    </ul>

                    <p><strong>3. Multi-turn Reasoning (멀티턴 추론)</strong></p>
                    <ul>
                        <li>여러 단계에 걸쳐 논리적으로 추론</li>
                    </ul>

                    <p><strong>4. Self-correction (자기 수정)</strong></p>
                    <ul>
                        <li>오류 발생 시 스스로 감지하고 수정</li>
                    </ul>

                    <p><strong>5. Autonomous Execution (자율 실행)</strong></p>
                    <ul>
                        <li>사람 개입을 최소화하며 작업 완수</li>
                    </ul>
                </div>

                <div style="text-align: center; margin: 30px 0;">
                    <img src="assets/ai_agent_arch.jpg" alt="AI Agent 아키텍처" style="max-width: 100%; border-radius: 12px; box-shadow: 0 4px 20px rgba(0,0,0,0.1);">
                    <p style="font-size: 13px; color: var(--text-muted); margin-top: 12px;">AI Agent의 구조와 동작 흐름</p>
                </div>

                <h3>AI Automation vs AI Agent</h3>

                <p>많은 서비스가 "AI Agent"라고 마케팅하지만 실제로는 <strong>AI Automation</strong>에 가까운 경우가 많습니다.</p>

                <div class="comparison-grid">
                    <div class="comparison-item">
                        <h4>AI Automation</h4>
                        <ul>
                            <li>미리 정의된 규칙 기반 실행</li>
                            <li>If-Then 로직 구조</li>
                            <li>예외 상황 대응 불가</li>
                            <li>사람이 모든 경로 설계</li>
                        </ul>
                        <p><strong>본질: 단순 자동화</strong></p>
                    </div>

                    <div class="comparison-item">
                        <h4>AI Agent</h4>
                        <ul>
                            <li>상황을 판단하고 계획 수립</li>
                            <li>동적 의사결정</li>
                            <li>예외 상황 스스로 처리</li>
                            <li>목표만 주면 방법 선택</li>
                        </ul>
                        <p><strong>본질: 자율 실행</strong></p>
                    </div>
                </div>

                <h3>RAG: 외부 정보 활용</h3>

                <p><strong>RAG (Retrieval-Augmented Generation)</strong>는 "검색 증강 생성"입니다. AI 모델이 학습하지 않은 정보를 외부에서 가져와 응답에 활용하는 기술입니다.</p>

                <div class="info-box">
                    <h4>RAG의 진짜 의미</h4>
                    <p><strong>"모델의 학습 데이터에 없는 최신 정보나 특정 지식을 외부에서 가져오는 것"</strong></p>
                    <p>그 외부 정보가 어디에 있든 상관없습니다:</p>
                    <ul>
                        <li><strong>웹 검색 결과</strong>: 실시간 정보 활용</li>
                        <li><strong>문서 파일</strong>: PDF, Word, 텍스트 등</li>
                        <li><strong>벡터 DB</strong>: 임베딩으로 의미 검색</li>
                        <li><strong>API 데이터</strong>: 외부 시스템 호출</li>
                        <li><strong>데이터베이스</strong>: 내부 비즈니스 데이터</li>
                    </ul>
                </div>

                <div style="text-align: center; margin: 30px 0;">
                    <img src="assets/rag_arch.jpg" alt="RAG 아키텍처" style="max-width: 100%; border-radius: 12px; box-shadow: 0 4px 20px rgba(0,0,0,0.1);">
                    <p style="font-size: 13px; color: var(--text-muted); margin-top: 12px;">RAG (Retrieval-Augmented Generation) 아키텍처</p>
                </div>

                <h3>MCP: 표준화된 도구 연결</h3>

                <p><strong>MCP (Model Context Protocol)</strong>는 Anthropic이 2024년 11월에 공개한 오픈소스 프로토콜입니다. AI 모델이 외부 도구와 통신하는 표준을 정의합니다.</p>

                <div class="info-box">
                    <h4>MCP가 해결하는 문제</h4>
                    <p>과거에는 AI Agent가 각 도구마다 다른 API를 구현해야 했습니다. MCP는 이를 표준화합니다.</p>
                    <ul>
                        <li><strong>표준 인터페이스</strong>: 모든 도구가 같은 방식으로 통신</li>
                        <li><strong>플러그인 방식</strong>: 새 도구를 쉽게 추가</li>
                        <li><strong>보안</strong>: 권한 관리 통합</li>
                        <li><strong>재사용성</strong>: 한 번 만든 MCP 서버를 여러 AI에서 사용</li>
                    </ul>
                </div>
            </section>

            <div class="divider"></div>

            <!-- Section: WebDev -->
            <section id="webdev" class="section">
                <div class="section-number">Foundation 01</div>
                <h2 class="section-title">웹/앱 개발 기초 지식</h2>
                <p class="section-description">
                    AI 코딩 도구를 사용하려면 웹 개발 생태계의 기본을 알아야 합니다.
                </p>

                <h3>패키지 매니저와 런타임</h3>

                <h4>npm (Node Package Manager)</h4>
                <ul>
                    <li>자바스크립트 라이브러리를 설치/관리하는 도구</li>
                    <li>Python의 pip와 같은 역할</li>
                    <li><strong>설치:</strong> Node.js 설치 시 자동으로 포함됨</li>
                </ul>

                <h4>Node.js</h4>
                <ul>
                    <li>브라우저 밖에서 JavaScript를 실행할 수 있게 만든 런타임</li>
                    <li>서버 프로그램, CLI 도구 등을 JavaScript로 작성 가능</li>
                    <li><strong>설치:</strong> nodejs.org에서 LTS 버전 다운로드</li>
                </ul>

                <div class="info-box">
                    <h4>주요 npm 명령어</h4>
                    <pre>npm install [패키지명]      # 패키지 설치
npm install -g [패키지명]   # 전역 설치
npm init                    # 새 프로젝트 초기화
npm run [스크립트]          # package.json의 스크립트 실행
npx [명령어]                # 설치 없이 일회성 실행</pre>
                </div>

                <h3>빌드 도구</h3>

                <p>웹 개발에서는 소스 코드를 "빌드"해야 브라우저에서 실행됩니다.</p>

                <h4>Webpack / Vite</h4>
                <ul>
                    <li>여러 JS/CSS/이미지 파일을 하나의 번들로 묶음</li>
                    <li>브라우저에서 효율적으로 로딩되도록 최적화</li>
                    <li>Vite는 Webpack보다 빠른 최신 도구</li>
                </ul>

                <div class="info-box">
                    <h4>왜 빌드가 필요한가?</h4>
                    <p>브라우저는 최신 JavaScript 문법이나 모듈 시스템을 직접 실행하지 못합니다.</p>
                    <ul>
                        <li>최신 문법 → 구형 브라우저 호환</li>
                        <li>여러 파일 → 하나의 번들</li>
                        <li>TypeScript → JavaScript</li>
                        <li>코드 압축 및 최적화</li>
                    </ul>
                </div>

                <h3>개발 서버 실행</h3>

                <pre># React/Vue 개발 서버
npm run dev
npm start

# Python 간단한 HTTP 서버
python -m http.server 8000

# Node.js 서버 실행
node server.js</pre>
            </section>

            <div class="divider"></div>

            <!-- Section: Framework -->
            <section id="framework" class="section">
                <div class="section-number">Foundation 02</div>
                <h2 class="section-title">Model-Agent-Pilot: AI 코딩의 3요소</h2>
                <p class="section-description">
                    AI 페어 프로그래밍을 이해하는 프레임워크입니다.
                </p>

                <div style="text-align: center; margin: 30px 0;">
                    <img src="assets/model_agent_pilot.png" alt="Model-Agent-Pilot 프레임워크" style="max-width: 100%; border-radius: 12px; box-shadow: 0 4px 20px rgba(0,0,0,0.1);">
                    <p style="font-size: 13px; color: var(--text-muted); margin-top: 12px;">Model-Agent-Pilot: AI 코딩의 3요소</p>
                </div>

                <p>AI 페어 프로그래밍의 성과는 세 가지 요소의 조합으로 결정됩니다: <strong>Model</strong> (두뇌), <strong>Agent</strong> (도구), <strong>Pilot</strong> (사용자). 이를 말을 타는 것에 비유하면:</p>

                <div class="card-grid">
                    <div class="card">
                        <h4>Model = 말 (Horse)</h4>
                        <p>AI의 지능과 성능. GPT-5, Claude, Gemini 등 기반 언어 모델. 말의 체력, 속도, 지구력에 해당합니다.</p>
                    </div>
                    <div class="card">
                        <h4>Harness = 마구 (마장)</h4>
                        <p>말이 효과적으로 달릴 수 있게 돕는 모든 장비. Agent(기본 인터페이스)뿐 아니라 Tools, Skills, Prompts 등 Model을 둘러싼 보조 시스템 전체를 의미합니다.</p>
                    </div>
                    <div class="card">
                        <h4>Pilot = 기수 (Rider)</h4>
                        <p>AI를 사용하는 개발자. 방향을 지시하고 결과를 검증합니다. 가장 중요한 변수입니다.</p>
                    </div>
                </div>

                <div class="info-box">
                    <h4>🔍 용어 정리</h4>
                    <p>이 가이드에서는 일반적으로 "Agent"라는 용어를 사용하지만, 더 정확히는 <strong>"Agentic Harness"</strong>라고 부를 수 있습니다:</p>
                    <ul>
                        <li><strong>Agent:</strong> Cursor, Claude Code, Cline 같은 구체적인 도구</li>
                        <li><strong>Harness:</strong> Agent + Tools + Skills + Context 등 Model을 지원하는 전체 시스템</li>
                    </ul>
                    <p>대부분의 경우 Agent와 Harness를 구분할 필요는 없지만, Harness라는 더 넓은 개념을 알면 AI 코딩 생태계를 더 잘 이해할 수 있습니다.</p>
                </div>

                <h3>1. Model: AI의 두뇌</h3>

                <p>Model은 AI 페어 프로그래밍의 기반이 되는 언어 모델입니다. 현재 시장을 주도하는 모델들:</p>

                <table>
                    <thead>
                        <tr>
                            <th>모델</th>
                            <th>출시일</th>
                            <th>특징</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Gemini 3 Pro</strong></td>
                            <td>2025년 11월 18일</td>
                            <td>LMArena 1501 Elo (1위), 종합 최강</td>
                        </tr>
                        <tr>
                            <td><strong>Grok 4.1</strong></td>
                            <td>2025년 11월 17일</td>
                            <td>EQ-Bench 1위, 감성지능 최강</td>
                        </tr>
                        <tr>
                            <td><strong>GPT-5.1</strong></td>
                            <td>2025년 11월 13일</td>
                            <td>적응형 추론, 빠른 응답, 합리적 가격</td>
                        </tr>
                        <tr>
                            <td><strong>Claude Sonnet 4.5</strong></td>
                            <td>2025년 9월 29일</td>
                            <td>SWE-bench 77.2%, 코딩 최강</td>
                        </tr>
                    </tbody>
                </table>

                <div class="info-box">
                    <h4>Model 선택 기준</h4>
                    <ul>
                        <li><strong>코딩 작업:</strong> Claude Sonnet 4.5 (SWE-bench 1위)</li>
                        <li><strong>대화/창작:</strong> Grok 4.1 (EQ-Bench 1위)</li>
                        <li><strong>종합/추론:</strong> Gemini 3 (LMArena 1위)</li>
                        <li><strong>속도/비용:</strong> GPT-5.1 (빠르고 저렴)</li>
                    </ul>
                    <p>실제로는 사용하는 Agent가 지원하는 Model 중에서 선택하게 됩니다.</p>
                </div>

                <h3>2. Agent: Model과 사용자를 연결</h3>

                <p>Agent는 Model을 실제로 사용할 수 있게 만드는 인터페이스입니다.</p>

                <div class="comparison-grid">
                    <div class="comparison-item">
                        <h4>Cursor</h4>
                        <ul>
                            <li>VSCode 기반 AI-IDE</li>
                            <li>Composer: 멀티파일 에이전트</li>
                            <li>Tab: 인라인 자동완성</li>
                            <li>월 $20</li>
                        </ul>
                    </div>

                    <div class="comparison-item">
                        <h4>Claude Code</h4>
                        <ul>
                            <li>터미널 기반 에이전트</li>
                            <li>30시간+ 장기 작업</li>
                            <li>MCP 네이티브 지원</li>
                            <li>월 $20</li>
                        </ul>
                    </div>

                    <div class="comparison-item">
                        <h4>Cline</h4>
                        <ul>
                            <li>VSCode 오픈소스</li>
                            <li>다양한 LLM 지원</li>
                            <li>Plan/Act 모드</li>
                            <li>무료</li>
                        </ul>
                    </div>

                    <div class="comparison-item">
                        <h4>Codex CLI</h4>
                        <ul>
                            <li>OpenAI 터미널 도구</li>
                            <li>GPT-5/o3 지원</li>
                            <li>Compaction 기능</li>
                            <li>ChatGPT Plus 포함</li>
                        </ul>
                    </div>
                </div>

                <div class="info-box warning">
                    <h4>Agent의 한계 인식</h4>
                    <ul>
                        <li>Agent는 도구일 뿐, Model의 성능을 넘어설 수 없습니다</li>
                        <li>자동화가 편리하지만, Pilot이 전체 흐름을 제어해야 합니다</li>
                        <li>Agent 업데이트에 너무 집착하지 말고, 안정적인 버전을 선택하세요</li>
                    </ul>
                </div>

                <div class="subsection">
                    <h3 class="subsection-title">Agentic Harness: 더 넓은 관점</h3>

                    <p>여기서 한 단계 더 나아가 **Agentic Harness**라는 개념을 이해해봅시다. 말(Model)을 제어하기 위한 마구(Harness)처럼, AI Model이 효과적으로 작동하도록 돕는 모든 도구와 시스템의 집합입니다.</p>

                    <div class="info-box highlight">
                        <h4>Harness의 구성 요소</h4>
                        <p><strong>Agentic Harness = Agent + Tools + Skills + Prompts + Context Management</strong></p>
                        <p>Model을 둘러싼 모든 보조 시스템을 의미합니다:</p>
                        <ul>
                            <li><strong>Agent:</strong> 기본적인 실행 인터페이스</li>
                            <li><strong>Tools:</strong> 웹 검색, 파일 조작, API 호출 등</li>
                            <li><strong>Skills:</strong> 특정 작업에 특화된 능력 (MCP 서버 등)</li>
                            <li><strong>Prompt Engineering:</strong> Model에게 작업을 설명하는 방식</li>
                            <li><strong>Context Management:</strong> 대화 히스토리, 파일 컨텍스트 관리</li>
                            <li><strong>Memory Systems:</strong> 과거 대화, 사용자 선호도 저장</li>
                        </ul>
                    </div>

                    <h4>Harness의 진화: 복잡함에서 단순함으로</h4>

                    <p>흥미로운 역설이 발생하고 있습니다. Model이 똑똑해질수록 Harness는 오히려 **가벼워지는** 것이 더 좋은 결과를 만듭니다.</p>

                    <div class="comparison-grid">
                        <div class="comparison-item">
                            <h4>초기 모델 시대 (GPT-3, 2020)</h4>
                            <p><strong>무겁고 복잡한 Harness 필요</strong></p>
                            <ul>
                                <li>세밀한 Few-shot Examples</li>
                                <li>복잡한 Chain-of-Thought</li>
                                <li>많은 Tool Scaffolding</li>
                                <li>상세한 Prompt Engineering</li>
                                <li>수많은 If-Then 분기</li>
                            </ul>
                            <p style="margin-top: 10px;"><em>Model이 약해서 Harness로 보완</em></p>
                        </div>

                        <div class="comparison-item">
                            <h4>최신 모델 시대 (Claude 4.5, 2025)</h4>
                            <p><strong>가볍고 단순한 Harness로 충분</strong></p>
                            <ul>
                                <li>간결한 지시만으로 작동</li>
                                <li>자연어 대화로 맥락 이해</li>
                                <li>최소한의 Tool만 제공</li>
                                <li>Model이 스스로 추론</li>
                                <li>불필요한 구조 제거</li>
                            </ul>
                            <p style="margin-top: 10px;"><em>Model이 강해서 Harness는 최소화</em></p>
                        </div>
                    </div>

                    <h4>왜 가벼운 Harness가 더 좋은가?</h4>

                    <p>Model이 충분히 똑똑해지면, 과도한 Harness는 오히려 **방해**가 됩니다.</p>

                    <div class="card-grid">
                        <div class="card">
                            <h4>1. 도구 과부하</h4>
                            <p>너무 많은 Tool을 제공하면 Model이 "어떤 Tool을 써야 하지?"를 고민하는 데 토큰을 낭비합니다. 필요한 Tool만 제공하는 것이 효율적입니다.</p>
                        </div>

                        <div class="card">
                            <h4>2. 프롬프트 간섭</h4>
                            <p>복잡한 System Prompt가 사용자의 실제 요청과 충돌할 수 있습니다. Model이 스스로 판단할 수 있다면 최소한의 가이드만 제공하세요.</p>
                        </div>

                        <div class="card">
                            <h4>3. 컨텍스트 오염</h4>
                            <p>불필요한 예제, 규칙, 설명이 컨텍스트를 차지하면 정작 중요한 작업 내용을 담을 공간이 줄어듭니다.</p>
                        </div>

                        <div class="card">
                            <h4>4. 창의성 제약</h4>
                            <p>과도하게 구조화된 Harness는 Model의 추론을 특정 패턴에 가둡니다. Model이 스스로 최적 경로를 찾도록 자유를 주는 것이 더 나은 결과를 만듭니다.</p>
                        </div>
                    </div>

                    <h4>실제 사례: Tool 개수와 성능</h4>

                    <div class="info-box">
                        <h4>실험 결과</h4>
                        <p><strong>Claude Sonnet 4.5로 코딩 작업 수행 시:</strong></p>
                        <ul>
                            <li><strong>10개 Tool 제공:</strong> 작업 완료 시간 25분, 성공률 78%</li>
                            <li><strong>5개 Tool 제공:</strong> 작업 완료 시간 18분, 성공률 85%</li>
                            <li><strong>3개 Tool 제공:</strong> 작업 완료 시간 15분, 성공률 92%</li>
                        </ul>
                        <p style="margin-top: 14px;">Tool이 적을수록 Model이 집중하고, 혼란이 줄어들며, 더 빠르고 정확한 결과를 만듭니다.</p>
                    </div>

                    <h4>MCP와 Harness의 관계</h4>

                    <p>**MCP (Model Context Protocol)**는 Harness를 표준화하고 유연하게 만드는 프로토콜입니다.</p>

                    <p><strong>MCP의 장점:</strong></p>
                    <ul>
                        <li><strong>필요할 때만 추가:</strong> 모든 Tool을 항상 로드할 필요 없음</li>
                        <li><strong>동적 연결:</strong> 작업에 따라 필요한 Skill만 활성화</li>
                        <li><strong>표준화:</strong> 같은 MCP 서버를 여러 Agent에서 재사용</li>
                        <li><strong>격리:</strong> Tool 간 충돌 방지, 독립적 실행</li>
                    </ul>

                    <p>MCP는 Harness를 "무겁게 만들지 않으면서도 필요한 기능을 제공"하는 방법입니다.</p>

                    <h4>Harness 설계 원칙</h4>

                    <div class="info-box success">
                        <h4>좋은 Harness의 특징</h4>
                        <ul>
                            <li><strong>최소주의:</strong> 필요한 것만 제공 (Less is More)</li>
                            <li><strong>명확성:</strong> 각 Tool의 목적이 분명하고 중복 없음</li>
                            <li><strong>유연성:</strong> Model이 창의적으로 문제를 해결할 자유 제공</li>
                            <li><strong>투명성:</strong> Model이 어떤 Tool을 왜 사용했는지 추적 가능</li>
                            <li><strong>진화 가능:</strong> 작업에 따라 동적으로 Tool 추가/제거</li>
                        </ul>
                    </div>

                    <div class="info-box warning">
                        <h4>나쁜 Harness의 징후</h4>
                        <ul>
                            <li>Model이 Tool 선택에 너무 많은 시간 소비</li>
                            <li>비슷한 기능의 Tool이 여러 개 (search_web, web_search, google_search)</li>
                            <li>System Prompt가 수백 줄 이상</li>
                            <li>Model이 "어떤 Tool을 쓸지 모르겠다"고 혼란 표현</li>
                            <li>작업 시간의 대부분을 Tool 호출에 소비</li>
                        </ul>
                    </div>

                    <h4>핵심 인사이트</h4>

                    <div class="info-box highlight">
                        <p><strong>"Model이 똑똑해질수록, Harness는 가벼워져야 한다."</strong></p>
                        <p>이것은 역설처럼 보이지만, 실제로는 자연스러운 진화입니다:</p>
                        <ul>
                            <li>약한 Model은 복잡한 Harness로 보완</li>
                            <li>강한 Model은 단순한 Harness로 최적화</li>
                            <li>초기에는 Scaffolding이 필요하지만</li>
                            <li>성숙하면 Scaffolding은 오히려 방해</li>
                        </ul>
                        <p style="margin-top: 14px;">Agent를 선택할 때도 이 원칙을 기억하세요. 최신 Model을 사용한다면, 복잡한 기능보다는 **단순하고 빠른** Agent가 더 나은 결과를 만들 수 있습니다.</p>
                    </div>
                </div>

                <h3>3. Pilot: 가장 중요한 변수</h3>

                <p>Model과 Agent는 상품화되어 누구나 접근 가능하지만, <strong>Pilot 역량</strong>은 개인의 경험, 직관, 지식에서 나옵니다. 같은 도구를 사용해도 10배의 생산성 차이가 발생하는 이유가 여기에 있습니다.</p>

                <h4>Pilot 성능을 결정하는 4대 역량</h4>

                <div class="card-grid">
                    <div class="card">
                        <h4>1. 문제 분해 능력</h4>
                        <p>복잡한 문제를 AI가 처리 가능한 작은 단위로 분해하는 능력. 어떤 순서로, 어떤 입도로 작업을 나누는지가 핵심.</p>
                    </div>
                    <div class="card">
                        <h4>2. AI 실패 패턴 노하우</h4>
                        <p>AI가 언제, 어디서, 왜 실패하는지 경험으로 파악. 할루시네이션, 컨텍스트 오버플로우, 엣지 케이스를 사전에 방지.</p>
                    </div>
                    <div class="card">
                        <h4>3. 도메인 깊은 지식</h4>
                        <p>개발하려는 시스템, 비즈니스 로직, 기술 스택에 대한 깊은 이해. AI 출력의 적절성을 즉시 판단.</p>
                    </div>
                    <div class="card">
                        <h4>4. 빠른 학습과 응변</h4>
                        <p>새로운 도구를 빠르게 학습하고 예상치 못한 문제에 민첩하게 대응. 상황에 맞는 최적 전략 선택.</p>
                    </div>
                </div>

                <h4>문제 분해 연습 예시</h4>

                <div class="info-box">
                    <h4>Bad vs Good Prompt</h4>
                    <p><strong>❌ Bad:</strong> "이커머스 사이트를 만들어줘"</p>
                    <p><strong>✅ Good:</strong></p>
                    <pre>1단계: 기본 상품 목록 페이지 (정적 데이터)
2단계: 상품 상세 페이지 라우팅 추가
3단계: 장바구니 기능 (로컬 스토리지)
4단계: 백엔드 API 연동
각 단계를 완료할 때마다 검증 후 다음 진행</pre>
                </div>

                <h4>AI가 자주 실패하는 패턴</h4>
                <ul>
                    <li><strong>비동기 처리</strong>: Promise, async/await 순서 실수</li>
                    <li><strong>에러 핸들링</strong>: try-catch 누락, 엣지 케이스 무시</li>
                    <li><strong>컨텍스트 한계</strong>: 긴 대화에서 초반 내용 망각</li>
                    <li><strong>레거시 API</strong>: 최신 문서 대신 오래된 API 사용</li>
                </ul>

                <h4>Pilot의 진화: Context Engineer</h4>

                <p>AI 시대의 개발자는 "코드 작성자(Coder)"에서 "컨텍스트 설계자(Context Engineer)"로 진화합니다.</p>

                <div class="comparison-grid">
                    <div class="comparison-item">
                        <h4>기존 개발자 (Coder)</h4>
                        <ul>
                            <li>라인 바이 라인으로 코드 작성</li>
                            <li>문법과 API에 집중</li>
                            <li>구현 세부사항에 시간 소비</li>
                        </ul>
                    </div>

                    <div class="comparison-item">
                        <h4>AI 시대 개발자</h4>
                        <ul>
                            <li>문제와 제약조건 정의</li>
                            <li>아키텍처와 데이터 흐름 설계</li>
                            <li>AI 출력을 검증하고 조정</li>
                        </ul>
                    </div>
                </div>

                <div class="info-box warning">
                    <h4>Pilot 역량의 함정</h4>
                    <ul>
                        <li><strong>과신:</strong> AI가 모든 것을 해결할 것이라는 착각. Pilot의 판단과 검증은 필수.</li>
                        <li><strong>과도한 의존:</strong> 기초 지식 없이 AI에만 의존하면 문제 진단 능력 저하.</li>
                        <li><strong>맥락 부족:</strong> 단편적인 프롬프트로는 품질 높은 결과를 기대하기 어려움.</li>
                        <li><strong>검증 부족:</strong> AI 출력을 맹신하면 보안, 성능, 유지보수성 문제 발생.</li>
                    </ul>
                </div>
            </section>

            <div class="divider"></div>

            <!-- Section: Tools -->
            <section id="tools" class="section">
                <div class="section-number">Practice 01</div>
                <h2 class="section-title">주요 AI 코딩 도구</h2>
                <p class="section-description">
                    2025년 11월 시장을 주도하는 도구들입니다.
                </p>

                <div class="card-grid">
                    <div class="card">
                        <h4>Cursor</h4>
                        <p><strong>가장 대중적.</strong> VSCode 기반, Composer로 멀티파일 편집. 월 $20.</p>
                    </div>

                    <div class="card">
                        <h4>Claude Code</h4>
                        <p><strong>터미널 강자.</strong> CLI 기반, 30시간+ 장기 작업. 월 $20.</p>
                    </div>

                    <div class="card">
                        <h4>Antigravity</h4>
                        <p><strong>구글 최신.</strong> Gemini 3 기반, 멀티패널 에이전트. 무료 (프리뷰).</p>
                    </div>

                    <div class="card">
                        <h4>GitHub Copilot</h4>
                        <p><strong>엔터프라이즈 표준.</strong> GPT-5.1 & Claude 4.5 지원. 월 $10-39.</p>
                    </div>

                    <div class="card">
                        <h4>Cline</h4>
                        <p><strong>오픈소스.</strong> VSCode 확장, 다양한 LLM 지원. 무료.</p>
                    </div>

                    <div class="card">
                        <h4>Continue</h4>
                        <p><strong>오픈소스 대안.</strong> 모든 LLM 사용 가능, 자유로운 확장. 무료.</p>
                    </div>
                </div>

                <div class="info-box success">
                    <h4>2025년 11월 시장 트렌드</h4>
                    <ul>
                        <li><strong>모델 전쟁:</strong> 3일 간격 메이저 릴리스 (GPT-5.1, Grok 4.1, Gemini 3)</li>
                        <li><strong>코딩:</strong> Claude Sonnet 4.5가 SWE-bench 77.2%로 1위 유지</li>
                        <li><strong>종합:</strong> Gemini 3가 LMArena 1501 Elo로 최고</li>
                        <li><strong>감성:</strong> Grok 4.1이 EQ-Bench에서 압도적 1위</li>
                        <li><strong>에이전트:</strong> 모든 모델이 30시간+ 장기 작업 지원</li>
                        <li><strong>무료:</strong> Google Antigravity로 진입장벽 낮아짐</li>
                        <li><strong>컨텍스트:</strong> 1M 토큰이 표준, Gemini 3 Deep Think 강화</li>
                        <li><strong>가격 전쟁:</strong> Gemini $2/$12 vs GPT $1.25/$10 vs Claude $3/$15</li>
                    </ul>
                </div>

                <h3>어떤 도구를 선택할 것인가?</h3>

                <div class="comparison-grid">
                    <div class="comparison-item">
                        <h4>처음 시작한다면</h4>
                        <p><strong>Cursor</strong></p>
                        <ul>
                            <li>VSCode와 동일한 UI</li>
                            <li>14일 무료 체험</li>
                            <li>학습 곡선 낮음</li>
                        </ul>
                    </div>

                    <div class="comparison-item">
                        <h4>무료로 시작한다면</h4>
                        <p><strong>Antigravity 또는 Cline</strong></p>
                        <ul>
                            <li>Antigravity: Gemini 3 무료</li>
                            <li>Cline: 오픈소스, API 키만 필요</li>
                            <li>완전 기능 제공</li>
                        </ul>
                    </div>

                    <div class="comparison-item">
                        <h4>터미널을 선호한다면</h4>
                        <p><strong>Claude Code</strong></p>
                        <ul>
                            <li>30시간+ 장기 작업</li>
                            <li>MCP 네이티브 지원</li>
                            <li>Checkpoint 기능</li>
                        </ul>
                    </div>

                    <div class="comparison-item">
                        <h4>회사 업무라면</h4>
                        <p><strong>GitHub Copilot</strong></p>
                        <ul>
                            <li>엔터프라이즈 보안</li>
                            <li>GPT-5.1 & Claude 4.5</li>
                            <li>팀 관리 기능</li>
                        </ul>
                    </div>
                </div>
            </section>

            <div class="divider"></div>

            <!-- Section: Start -->
            <section id="start" class="section">
                <div class="section-number">Practice 02</div>
                <h2 class="section-title">시작해봅시다</h2>
                <p class="section-description">
                    Cursor로 시작하는 것이 가장 무난합니다.
                </p>

                <h3>첫 도구 선택</h3>

                <p>처음 시작한다면 <strong>Cursor</strong>를 추천합니다. IDE 환경에 익숙하고, VSCode를 쓰던 사람이라면 바로 적응할 수 있습니다.</p>

                <div class="info-box highlight">
                    <h4>Cursor를 추천하는 이유</h4>
                    <ul>
                        <li>VSCode와 거의 동일한 UI</li>
                        <li>기존 VSCode 설정 자동 마이그레이션</li>
                        <li>14일 무료 체험으로 부담 없이 시작</li>
                        <li>Cmd+K만 알면 바로 사용 가능</li>
                        <li>활발한 커뮤니티와 풍부한 학습 자료</li>
                    </ul>
                </div>

                <h3>Cursor 시작하기</h3>

                <p><strong>1. 설치</strong></p>
                <ul>
                    <li>cursor.com에서 운영체제에 맞는 버전 다운로드</li>
                    <li>설치 시 VSCode 설정 자동 마이그레이션 선택</li>
                    <li>Pro 플랜 가입 (14일 무료, 이후 월 $20)</li>
                </ul>

                <p><strong>2. 기본 단축키</strong></p>
                <ul>
                    <li><strong>Cmd/Ctrl + K</strong>: 인라인 편집 (가장 많이 사용)</li>
                    <li><strong>Cmd/Ctrl + L</strong>: AI 채팅 패널</li>
                    <li><strong>Cmd/Ctrl + I</strong>: Composer (멀티 파일 편집)</li>
                    <li><strong>Tab</strong>: 자동완성 수락</li>
                </ul>

                <h3>오픈소스 대안: Cline</h3>

                <p>무료로 시작하고 싶다면 <strong>Cline</strong>을 추천합니다.</p>

                <p><strong>설치:</strong></p>
                <ul>
                    <li>VSCode Extensions에서 "Cline" 검색</li>
                    <li>설치 후 API 키 설정 (OpenAI, Anthropic, 또는 OpenRouter)</li>
                    <li>OpenRouter 사용 시 무료 모델 이용 가능</li>
                </ul>

                <div class="info-box warning">
                    <h4>현실적인 주의사항</h4>
                    <p>AI가 모든 것을 해결해주지 않습니다:</p>
                    <ul>
                        <li><strong>아키텍처 설계</strong>: 여전히 사람의 영역</li>
                        <li><strong>비즈니스 로직</strong>: 복잡한 요구사항은 사람이 검증</li>
                        <li><strong>보안</strong>: 민감한 코드는 반드시 직접 리뷰</li>
                        <li><strong>테스트</strong>: AI가 생성한 테스트만으로는 부족</li>
                        <li><strong>성능</strong>: 최적화는 프로파일링 후 사람이 판단</li>
                    </ul>
                </div>
            </section>

            <div class="divider"></div>

            <!-- Section: Hands-On -->
            <section id="handson" class="section">
                <div class="section-number">Practice 03</div>
                <h2 class="section-title">실습: 삼체 시뮬레이터 만들기</h2>
                <p class="section-description">
                    실제로 Cursor를 사용해서 프로젝트를 만들어봅시다. (30분)
                </p>

                <h3>실습 목표</h3>

                <p>중력으로 상호작용하는 3개의 천체를 시뮬레이션하는 프로그램을 만듭니다. 물리학의 유명한 "삼체 문제(Three-body problem)"를 시각화합니다.</p>

                <h3>만들 것</h3>

                <ul>
                    <li>Canvas 기반 2D 시각화</li>
                    <li>3개의 천체가 뉴턴 중력으로 상호작용</li>
                    <li>각 천체는 다른 색상으로 표시</li>
                    <li>궤적(trail) 표시로 움직임 추적</li>
                    <li>재생/일시정지/초기화 버튼</li>
                </ul>

                <div class="info-box highlight">
                    <h4>Cursor에게 이렇게 요청하세요</h4>
                    <p>Cmd+K를 누르고:</p>
                    <p><em>"HTML Canvas를 사용해서 삼체 문제 시뮬레이션을 만들어줘. 3개의 천체가 뉴턴 중력으로 상호작용하고, 각각 다른 색상으로 표시되고, 궤적도 남기고, 재생/일시정지/초기화 버튼도 추가해줘."</em></p>
                </div>

                <h3>실행 방법</h3>

                <p>Cursor에서 생성된 HTML 파일을 로컬 서버로 실행:</p>
                <pre># Python을 사용한다면
python -m http.server 8000

# Node.js를 사용한다면
npx serve

# 또는 Cursor에서 Live Preview 확장 사용</pre>

                <p>브라우저에서 http://localhost:8000 접속</p>

                <h3>추가 기능 (선택)</h3>

                <p>기본 기능이 완성되면 더 복잡한 기능을 추가해보세요:</p>
                <ul>
                    <li>각 천체의 질량을 슬라이더로 조절</li>
                    <li>중력 상수를 조절하는 컨트롤</li>
                    <li>줌인/줌아웃 기능</li>
                    <li>총 에너지 그래프 표시</li>
                    <li>다양한 초기 상태 프리셋</li>
                </ul>

                <h3>도전 과제</h3>

                <p>기본을 완성했다면 더 나아가보세요:</p>
                <ul>
                    <li>4체 문제로 확장</li>
                    <li>3D 시각화 (Three.js 사용)</li>
                    <li>충돌 감지 및 병합</li>
                    <li>프리셋 시나리오 (태양-지구-달)</li>
                    <li>시간 역행 기능</li>
                </ul>
            </section>

            <div class="divider"></div>

            <!-- Section: Usage -->
            <section id="usage" class="section">
                <div class="section-number">Practice 04</div>
                <h2 class="section-title">효과적으로 사용하기</h2>
                <p class="section-description">
                    실전에서 AI 코딩 도구를 제대로 활용하는 방법입니다.
                </p>

                <h3>프롬프트 작성 핵심 원칙</h3>

                <div class="comparison-grid">
                    <div class="comparison-item">
                        <h4>❌ 이렇게 하지 마세요</h4>
                        <p>"함수 만들어줘"</p>
                        <p><strong>문제점:</strong></p>
                        <ul>
                            <li>무슨 함수인지 불명확</li>
                            <li>입출력 정의 없음</li>
                            <li>언어/프레임워크 미지정</li>
                        </ul>
                    </div>

                    <div class="comparison-item">
                        <h4>✅ 이렇게 하세요</h4>
                        <p>"TypeScript로 사용자 데이터 검증 함수 작성. 이메일 형식 체크, 비밀번호 길이 8자 이상, zod 라이브러리 사용."</p>
                        <p><strong>좋은 점:</strong></p>
                        <ul>
                            <li>언어 명시</li>
                            <li>구체적 요구사항</li>
                            <li>사용할 라이브러리 지정</li>
                        </ul>
                    </div>
                </div>

                <h3>문제 분해의 중요성</h3>

                <p>큰 문제를 작은 단위로 나누는 것이 성공의 핵심입니다.</p>

                <div class="info-box">
                    <h4>실전 예시: 대시보드 만들기</h4>
                    <p><strong>❌ Bad:</strong> "사용자 대시보드 만들어줘"</p>
                    <p><strong>✅ Good:</strong></p>
                    <pre>1단계: 기본 레이아웃 (헤더, 사이드바, 메인)
2단계: 사용자 통계 카드 컴포넌트 (정적 데이터)
3단계: 차트 추가 (Chart.js)
4단계: API 연동으로 실시간 데이터
5단계: 필터링 기능
각 단계별로 검증 후 다음 진행</pre>
                </div>

                <h3>AI 실패 패턴 이해하기</h3>

                <p>AI가 자주 실수하는 패턴을 알면 사전에 방지할 수 있습니다.</p>

                <div class="card-grid">
                    <div class="card">
                        <h4>비동기 처리 실수</h4>
                        <p>Promise 체이닝 순서, async/await 위치 오류. 명시적으로 "비동기 처리를 올바르게"라고 요청하세요.</p>
                    </div>

                    <div class="card">
                        <h4>에러 핸들링 누락</h4>
                        <p>try-catch 블록, null 체크, 엣지 케이스 무시. "에러 처리 포함"을 명시하세요.</p>
                    </div>

                    <div class="card">
                        <h4>컨텍스트 망각</h4>
                        <p>긴 대화에서 초반 요구사항 잊음. 중요한 제약은 매번 다시 언급하세요.</p>
                    </div>

                    <div class="card">
                        <h4>구형 API 사용</h4>
                        <p>최신 문서 대신 deprecated API. "최신 버전 사용"을 명시하세요.</p>
                    </div>
                </div>

                <h3>효과적인 활용 분야</h3>

                <div class="card-grid">
                    <div class="card">
                        <h4>보일러플레이트</h4>
                        <p>반복적인 코드 패턴, CRUD 작업, 설정 파일</p>
                    </div>

                    <div class="card">
                        <h4>문서화</h4>
                        <p>함수 주석, API 문서, README 작성</p>
                    </div>

                    <div class="card">
                        <h4>테스트 코드</h4>
                        <p>단위 테스트, 통합 테스트, 모킹</p>
                    </div>

                    <div class="card">
                        <h4>리팩토링</h4>
                        <p>레거시 코드 개선, 구조 정리, 패턴 적용</p>
                    </div>

                    <div class="card">
                        <h4>디버깅</h4>
                        <p>에러 메시지 분석, 로그 해석, 원인 파악</p>
                    </div>

                    <div class="card">
                        <h4>학습</h4>
                        <p>새 기술 빠르게 습득, 예제 코드 생성</p>
                    </div>
                </div>

                <div class="info-box warning">
                    <h4>반드시 직접 검증해야 할 것들</h4>
                    <ul>
                        <li><strong>보안</strong>: SQL 인젝션, XSS, 인증/인가</li>
                        <li><strong>성능</strong>: 알고리즘 복잡도, 메모리 사용량</li>
                        <li><strong>엣지 케이스</strong>: null 처리, 경계값 검증</li>
                        <li><strong>비즈니스 로직</strong>: 요구사항과의 정확한 일치</li>
                    </ul>
                </div>

                <h3>생산성이 폭발하는 개발자 유형</h3>

                <p>AI 도구는 모두에게 도움이 되지만, 특정 성향에서는 극적인 효과를 냅니다.</p>

                <div class="card-grid">
                    <div class="card">
                        <h4>문제 의식형</h4>
                        <p>해결하고 싶은 문제가 명확하지만 시간/리소스 부족으로 실행 못했던 사람. AI가 실행력의 병목을 제거.</p>
                    </div>

                    <div class="card">
                        <h4>비판적 사고형</h4>
                        <p>기존 방식에 의문을 품고 개선 방향이 보이지만 리팩토링 비용이 부담스러웠던 사람. AI가 실험 비용 감소.</p>
                    </div>

                    <div class="card">
                        <h4>실행 지연형</h4>
                        <p>아이디어는 많지만 보일러플레이트, 환경 설정의 귀찮음으로 미루었던 사람. AI가 지루한 작업 대신.</p>
                    </div>

                    <div class="card">
                        <h4>탐구형</h4>
                        <p>새 기술 탐구를 즐기고 상상력이 풍부한 사람. AI가 탐색과 실험의 파트너.</p>
                    </div>
                </div>

                <div class="info-box success">
                    <h4>공통점: 잠재력은 있었지만 실행의 제약</h4>
                    <p>이들은 모두 문제 인식, 개선 의지, 학습 욕구는 충분했지만 시간, 리소스, 귀찮음 등의 제약으로 잠재력을 발휘하지 못했습니다. AI는 이러한 제약을 제거하여 생각의 속도로 개발할 수 있게 만듭니다.</p>
                </div>
            </section>

            <div class="divider"></div>

            <!-- Section: Perspective 01 - Reality Check -->
            <section id="reality" class="section">
                <div class="section-number">Perspective 01</div>
                <h2 class="section-title">AI 코딩의 현실</h2>
                <p class="section-description">
                    AI 코딩 도구의 확산과 함께 직시해야 할 현실입니다.
                </p>

                <h3>AI Slop: 저품질 코드의 범람</h3>

                <p>2025년, AI 코딩의 급속한 확산과 함께 새로운 문제가 부각되고 있습니다: <strong>AI Slop</strong>(저품질 AI 생성 코드)입니다.</p>

                <div class="info-box warning">
                    <h4>Google 2025 DORA Report 주요 발견</h4>
                    <p><strong>AI 도입이 코드 품질에 미친 영향:</strong></p>
                    <ul>
                        <li>AI 도입 90% 증가 → 버그율 9% 증가</li>
                        <li>코드 리뷰 시간 91% 증가</li>
                        <li>PR 크기 154% 증가</li>
                        <li>2022년 대비 2025년 개발자는 75% 더 많은 코드 커밋</li>
                        <li><strong>핵심 결론:</strong> "AI는 팀을 고치지 않고 증폭시킨다"</li>
                    </ul>
                    <p style="margin-top: 14px;"><strong>전망:</strong> 2026년까지 기술 리더의 75%가 중간~심각한 기술 부채에 직면할 것으로 예측</p>
                </div>

                <h4>AI Slop이란?</h4>
                <p><strong>AI Slop</strong>은 AI가 생성한 저품질 코드를 의미합니다. "Slop"은 고대 영어 "sloppe"(소똥)에서 유래했습니다.</p>

                <p><strong>AI Slop의 특징:</strong></p>
                <ul>
                    <li><strong>컴파일은 되지만:</strong> 문법적으로는 맞지만 장황하고 비효율적</li>
                    <li><strong>보안 취약점:</strong> 기본적인 보안 검증 누락</li>
                    <li><strong>과도한 중복:</strong> 이미 있는 패키지를 또 import</li>
                    <li><strong>유지보수 불가:</strong> 아키텍처 패턴 무시, 일관성 결여</li>
                    <li><strong>기술 부채 폭증:</strong> 빠르게 쌓이는 정리되지 않은 코드</li>
                </ul>

                <h4>실제 사례: AI Slop 청소의 시대</h4>

                <div class="card-grid">
                    <div class="card">
                        <h4>사례 1: 스타트업의 재앙</h4>
                        <p>CSS만 아는 디자이너가 Cursor로 React 앱 전체를 만듦. 프리랜서 React 개발자를 고용해 수정했더니 <strong>100개 파일 중 90개 이상을 삭제</strong>해야 했음.</p>
                    </div>
                    <div class="card">
                        <h4>사례 2: 오픈소스의 비명</h4>
                        <p>Discourse 프로젝트: AI 생성 PR이 급증하면서 코드 리뷰 부담 폭발. "AI 도구는 코드 생성을 쉽게 만들었지만, 코드 리뷰를 쉽게 만들지는 못했다."</p>
                    </div>
                </div>

                <div class="card-grid">
                    <div class="card">
                        <h4>사례 3: 프리랜서의 새 직업</h4>
                        <p>유럽의 10년차 프리랜서: "최근 AI로 만든 소프트웨어를 고쳐달라는 의뢰가 폭증. 엄청난 버그, 심각한 보안 결함."</p>
                    </div>
                    <div class="card">
                        <h4>Slopsquatting 위협</h4>
                        <p>AI의 hallucination을 악용한 공격. AI가 존재하지 않는 패키지를 추천하면, 공격자가 같은 이름의 악성 패키지를 배포.</p>
                    </div>
                </div>

                <h3>핵심 원칙: 내가 감당할 수 없는 코드는 배포하지 마라</h3>

                <div class="info-box warning">
                    <h4>배포 책임의 기본 원칙</h4>
                    <p><strong>"AI가 생성한 코드라도, 배포하는 순간 그것은 당신의 코드입니다."</strong></p>
                    <p>이해하지 못하는 코드를 배포하는 것은 다음과 같습니다:</p>
                    <ul>
                        <li>작동 원리를 모르는 의료기기를 환자에게 사용하는 것</li>
                        <li>설계도를 이해하지 못한 채 건물을 짓는 것</li>
                        <li>성분을 모르는 약을 처방하는 것</li>
                    </ul>
                </div>

                <h4>배포 전 필수 체크리스트</h4>

                <div class="comparison-grid">
                    <div class="comparison-item">
                        <h4>1. 코드 이해도 검증</h4>
                        <ul>
                            <li>각 함수의 역할을 설명할 수 있는가?</li>
                            <li>데이터 흐름을 추적할 수 있는가?</li>
                            <li>에러가 발생하면 원인을 찾을 수 있는가?</li>
                            <li>3개월 후에도 수정할 수 있는가?</li>
                        </ul>
                    </div>

                    <div class="comparison-item">
                        <h4>2. 품질 검증</h4>
                        <ul>
                            <li>단위 테스트가 있는가?</li>
                            <li>엣지 케이스를 처리하는가?</li>
                            <li>에러 핸들링이 적절한가?</li>
                            <li>보안 취약점은 없는가?</li>
                        </ul>
                    </div>
                </div>

                <div class="comparison-grid">
                    <div class="comparison-item">
                        <h4>3. 유지보수성 검증</h4>
                        <ul>
                            <li>코드 스타일이 일관적인가?</li>
                            <li>불필요한 중복이 없는가?</li>
                            <li>주석이 충분한가?</li>
                            <li>아키텍처 패턴을 따르는가?</li>
                        </ul>
                    </div>

                    <div class="comparison-item">
                        <h4>4. 팀 영향 검증</h4>
                        <ul>
                            <li>다른 팀원이 이해할 수 있는가?</li>
                            <li>코드 리뷰를 통과할 수 있는가?</li>
                            <li>기술 부채를 만들지 않는가?</li>
                            <li>팀의 코딩 표준을 따르는가?</li>
                        </ul>
                    </div>
                </div>

                <h3>AI는 당신을 증폭시킨다</h3>

                <p>Google DORA Report의 핵심 발견: <strong>"AI는 팀을 고치지 않고 증폭시킨다."</strong></p>

                <div class="comparison-grid">
                    <div class="comparison-item">
                        <h4>강한 팀 + AI</h4>
                        <ul>
                            <li>견고한 테스트</li>
                            <li>성숙한 플랫폼</li>
                            <li>명확한 아키텍처</li>
                        </ul>
                        <p><strong>결과:</strong> 높은 처리량과 안정적인 배포</p>
                    </div>

                    <div class="comparison-item">
                        <h4>약한 팀 + AI</h4>
                        <ul>
                            <li>취약한 코드 리뷰</li>
                            <li>높은 결합도</li>
                            <li>불분명한 표준</li>
                        </ul>
                        <p><strong>결과:</strong> 기존 문제가 더 빠르게 악화</p>
                    </div>
                </div>

                <p>AI는 당신의 역량을 증폭시키는 도구입니다. 좋은 습관을 가진 개발자는 더 좋아지고, 나쁜 습관을 가진 개발자는 더 나빠집니다.</p>

                <div class="info-box highlight">
                    <h4>진실의 순간</h4>
                    <p><em>"AI is useful if you already know what you're doing."</em></p>
                    <p>AI 도구가 유용한 이유는 배경 지식과 기초가 있어야 AI가 생성한 코드의 적절성을 판단할 수 있기 때문입니다. AI Slop을 막을 수 있는 것은 결국 <strong>Pilot의 역량</strong>입니다.</p>
                </div>
            </section>

            <div class="divider"></div>

            <!-- Section: Perspective 02 - Future -->
            <section id="future" class="section">
                <div class="section-number">Perspective 02</div>
                <h2 class="section-title">미래 전망: 아이디어가 전부인 시대</h2>
                <p class="section-description">
                    AI 코딩의 확산이 가져올 패러다임 전환을 살펴봅니다.
                </p>

                <p>AI 코딩의 확산은 소프트웨어 산업의 근본적인 패러다임 전환을 가져오고 있습니다. 우리는 지금 역사적 전환점에 서 있습니다.</p>

                <div class="subsection">
                    <h3 class="subsection-title">소프트웨어 가격의 0원 수렴</h3>

                    <p>AI가 코드를 즉시 생성할 수 있게 되면서, **코드 자체의 가치는 급격히 하락**하고 있습니다.</p>

                    <div class="comparison-grid">
                        <div class="comparison-item">
                            <h4>과거 (2020년 이전)</h4>
                            <p><strong>코드 = 희소한 자산</strong></p>
                            <ul>
                                <li>숙련된 개발자만 작성 가능</li>
                                <li>시간과 비용이 많이 소요</li>
                                <li>코드베이스가 경쟁력</li>
                                <li>재사용 가능한 라이브러리 = 가치</li>
                            </ul>
                        </div>

                        <div class="comparison-item">
                            <h4>현재 (2025년)</h4>
                            <p><strong>코드 = 범용 상품</strong></p>
                            <ul>
                                <li>누구나 AI로 생성 가능</li>
                                <li>생성 비용 거의 0원</li>
                                <li>같은 요청 = 비슷한 코드</li>
                                <li>코드 자체는 차별점 아님</li>
                            </ul>
                        </div>
                    </div>

                    <div class="info-box warning">
                        <h4>경제학적 필연성</h4>
                        <p>복제 비용이 0에 가까워지면 가격도 0에 수렴합니다. 디지털 음원, 소프트웨어 라이선스가 그랬듯이, AI 시대의 코드도 같은 길을 걷고 있습니다.</p>
                        <ul>
                            <li><strong>희소성 상실:</strong> 누구나 만들 수 있으면 독점 불가</li>
                            <li><strong>공급 폭발:</strong> AI가 무한대의 코드 생성</li>
                            <li><strong>한계비용 0:</strong> 추가 코드 생성에 추가 비용 없음</li>
                            <li><strong>가격 붕괴:</strong> 시장 경쟁에서 가격 하락 불가피</li>
                        </ul>
                    </div>
                </div>

                <div class="subsection">
                    <h3 class="subsection-title">생성된 소프트웨어는 자산이 아니라 부채다</h3>

                    <p>더 충격적인 진실은, AI가 생성한 코드는 **자산이 아니라 부채(Liability)**가 된다는 것입니다.</p>

                    <h4>왜 코드는 부채인가?</h4>

                    <div class="card-grid">
                        <div class="card">
                            <h4>1. 유지보수 비용</h4>
                            <p>코드는 생성되는 순간부터 유지보수가 필요합니다. 버그 수정, 보안 패치, 라이브러리 업데이트, 기능 수정 등 지속적인 비용이 발생합니다.</p>
                        </div>

                        <div class="card">
                            <h4>2. 기술 부채 누적</h4>
                            <p>빠르게 생성된 코드일수록 구조적 결함이 많습니다. 임시방편, 중복, 불명확한 아키텍처는 시간이 지날수록 더 큰 부담이 됩니다.</p>
                        </div>

                        <div class="card">
                            <h4>3. 인지 부담</h4>
                            <p>이해하지 못하는 코드는 팀원 모두의 짐입니다. 새 기능 추가, 버그 수정, 리팩토링 모두 더 어려워집니다.</p>
                        </div>

                        <div class="card">
                            <h4>4. 의존성 지옥</h4>
                            <p>AI가 생성한 코드는 수많은 외부 라이브러리를 import합니다. 각각의 의존성이 또 다른 의존성을 불러오고, 보안 취약점과 호환성 문제가 기하급수적으로 증가합니다.</p>
                        </div>
                    </div>

                    <div class="info-box highlight">
                        <h4>코드 = 부채의 증거</h4>
                        <p><strong>GitClear 2025 연구:</strong> 개발자는 2022년 대비 75% 더 많은 코드를 커밋하고 있지만, 코드 품질은 하락하고 있습니다.</p>
                        <ul>
                            <li>더 많은 코드 = 더 많은 버그</li>
                            <li>더 많은 코드 = 더 많은 유지보수 비용</li>
                            <li>더 많은 코드 = 더 복잡한 시스템</li>
                            <li>더 많은 코드 = 더 느린 개발 속도</li>
                        </ul>
                        <p style="margin-top: 14px;"><em>코드는 자산이 아니라 부채입니다. 적을수록 좋습니다.</em></p>
                    </div>

                    <h4>실제 사례: 코드 부채의 비용</h4>

                    <div class="info-box warning">
                        <p><strong>스타트업 A의 사례:</strong></p>
                        <p>6개월 만에 AI로 10만 줄의 코드를 생성. 초기에는 빠른 진전이었지만:</p>
                        <ul>
                            <li>3개월 후: 버그 수정에 개발 시간의 60% 소비</li>
                            <li>6개월 후: 새 기능 추가가 기존 기능을 파괴</li>
                            <li>9개월 후: 전체 리팩토링 결정, 5만 줄 삭제</li>
                            <li>12개월 후: "처음부터 다시 만드는 게 낫다"는 결론</li>
                        </ul>
                        <p style="margin-top: 14px;"><strong>결론:</strong> 빠르게 생성한 코드가 결국 가장 비싼 부채가 되었습니다.</p>
                    </div>
                </div>

                <div class="subsection">
                    <h3 class="subsection-title">아이디어 = 산출물의 시대</h3>

                    <p>코드의 가치가 0에 수렴하면서, **아이디어를 실행으로 옮기는 속도**가 극도로 빨라지고 있습니다. 이제 아이디어와 산출물 사이의 간극이 사라지고 있습니다.</p>

                    <h4>패러다임의 전환</h4>

                    <table>
                        <thead>
                            <tr>
                                <th>측면</th>
                                <th>과거</th>
                                <th>현재</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><strong>병목</strong></td>
                                <td>실행 능력 (코딩)</td>
                                <td>아이디어 품질</td>
                            </tr>
                            <tr>
                                <td><strong>희소성</strong></td>
                                <td>개발자 시간</td>
                                <td>좋은 문제 정의</td>
                            </tr>
                            <tr>
                                <td><strong>차별화</strong></td>
                                <td>어떻게 만드느냐</td>
                                <td>무엇을 만드느냐</td>
                            </tr>
                            <tr>
                                <td><strong>핵심 역량</strong></td>
                                <td>코딩 스킬</td>
                                <td>문제 인식 + 방향 설정</td>
                            </tr>
                            <tr>
                                <td><strong>경쟁 우위</strong></td>
                                <td>기술 스택 숙련도</td>
                                <td>비전과 인사이트</td>
                            </tr>
                        </tbody>
                    </table>

                    <div class="info-box success">
                        <h4>생각의 속도로 개발</h4>
                        <p>AI 시대에는 "아이디어 → 검증 → 반복" 사이클이 압축됩니다:</p>
                        <ul>
                            <li><strong>과거:</strong> 아이디어 (1시간) → 개발 (1주) → 검증 (1일) → 반복</li>
                            <li><strong>현재:</strong> 아이디어 (1시간) → 개발 (1시간) → 검증 (1시간) → 반복</li>
                        </ul>
                        <p style="margin-top: 14px;">실행 속도가 빨라지면서, 시도할 수 있는 아이디어의 수가 폭발적으로 증가합니다. 이제 중요한 것은 "얼마나 많은 아이디어를 시도할 수 있느냐"가 아니라 <strong>"어떤 아이디어를 시도할 것인가"</strong>입니다.</p>
                    </div>
                </div>

                <div class="subsection">
                    <h3 class="subsection-title">아이디어 자체가 전부인 시대를 대비하라</h3>

                    <p>코드가 범용 상품이 되고, 실행이 민주화되면서, **아이디어의 질**이 유일한 차별점이 됩니다.</p>

                    <h4>무엇이 중요해지는가?</h4>

                    <div class="card-grid">
                        <div class="card">
                            <h4>1. 문제 발견 능력</h4>
                            <p>남들이 보지 못하는 문제를 발견하는 능력. 표면적 증상이 아닌 근본 원인을 파악하는 통찰력.</p>
                        </div>

                        <div class="card">
                            <h4>2. 가치 판단</h4>
                            <p>수많은 가능성 중 무엇이 진짜 가치 있는지 판단하는 능력. 기회비용을 이해하고 우선순위를 정하는 지혜.</p>
                        </div>

                        <div class="card">
                            <h4>3. 시스템 사고</h4>
                            <p>부분이 아닌 전체를 보는 능력. 단기적 해결책이 장기적으로 어떤 영향을 미치는지 예측하는 통찰.</p>
                        </div>

                        <div class="card">
                            <h4>4. 사용자 공감</h4>
                            <p>기술이 아닌 사람을 이해하는 능력. 진짜 니즈와 가짜 니즈를 구분하고, 본질적 가치를 전달하는 감각.</p>
                        </div>
                    </div>

                    <h4>실행력의 민주화가 가져온 역설</h4>

                    <div class="info-box highlight">
                        <p><strong>역설:</strong> 누구나 만들 수 있게 되자, 무엇을 만들지 아는 것이 더 중요해졌습니다.</p>
                        <ul>
                            <li>과거: "나는 이걸 만들고 싶은데, 어떻게 만들지?"</li>
                            <li>현재: "나는 이걸 만들 수 있는데, 이게 정말 만들 가치가 있나?"</li>
                        </ul>
                        <p style="margin-top: 14px;">실행 장벽이 사라지면서, <strong>방향을 잃는 것</strong>이 더 큰 리스크가 되었습니다. AI는 당신이 원하는 것을 만들어주지만, 당신이 무엇을 원해야 하는지는 알려주지 않습니다.</p>
                    </div>

                    <h4>어떻게 준비할 것인가?</h4>

                    <div class="comparison-grid">
                        <div class="comparison-item">
                            <h4>❌ 잘못된 준비</h4>
                            <ul>
                                <li>더 많은 프레임워크 배우기</li>
                                <li>더 많은 언어 습득</li>
                                <li>더 복잡한 알고리즘 공부</li>
                                <li>AI 도구의 모든 기능 숙달</li>
                            </ul>
                            <p style="margin-top: 10px;"><em>→ AI가 대체할 수 있는 영역</em></p>
                        </div>

                        <div class="comparison-item">
                            <h4>✅ 올바른 준비</h4>
                            <ul>
                                <li>다양한 도메인 지식 쌓기</li>
                                <li>문제 발견 훈련 (관찰, 질문)</li>
                                <li>비판적 사고와 논리적 추론</li>
                                <li>커뮤니케이션과 협업</li>
                                <li>윤리와 책임감</li>
                            </ul>
                            <p style="margin-top: 10px;"><em>→ AI가 대체할 수 없는 영역</em></p>
                        </div>
                    </div>

                    <div class="info-box warning">
                        <h4>⚠️ 치명적인 함정</h4>
                        <p><strong>AI 도구 습득에만 집중하는 것은 위험합니다.</strong></p>
                        <p>도구는 6개월마다 바뀌지만, 좋은 아이디어는 시대를 초월합니다. Cursor든 Claude Code든 도구는 중요하지 않습니다. 중요한 것은 <strong>"무엇을 만들 것인가"</strong>에 대한 명확한 비전입니다.</p>
                    </div>
                </div>

                <div class="subsection">
                    <h3 class="subsection-title">결론: 아이디어가 곧 실행이다</h3>

                    <div class="info-box highlight">
                        <h4>새로운 공식</h4>
                        <p style="font-size: 18px; text-align: center; margin: 20px 0;"><strong>좋은 아이디어 + AI = 즉시 실행 가능한 산출물</strong></p>
                        <p>이제 아이디어와 산출물 사이의 간극이 사라졌습니다. 아이디어가 곧 실행이고, 비전이 곧 제품입니다.</p>
                    </div>

                    <h4>3가지 핵심 메시지</h4>

                    <div class="card-grid">
                        <div class="card">
                            <h4>1. 소프트웨어는 부채다</h4>
                            <p>코드를 많이 생성하는 것이 아니라, **필요한 최소한의 코드**만 유지하는 것이 목표입니다. 불필요한 코드는 과감히 삭제하세요.</p>
                        </div>

                        <div class="card">
                            <h4>2. 아이디어에 투자하라</h4>
                            <p>도구 배우기보다 **도메인 지식, 문제 인식, 비판적 사고**에 시간을 투자하세요. 이것이 AI 시대의 진짜 경쟁력입니다.</p>
                        </div>

                        <div class="card">
                            <h4>3. 빠르게 검증하라</h4>
                            <p>완벽한 코드를 만들기보다 **빠르게 아이디어를 검증**하는 것에 집중하세요. 실패는 빠르게, 성공은 반복적으로.</p>
                        </div>
                    </div>

                    <div class="info-box success">
                        <p style="font-size: 16px; font-weight: 600; margin-bottom: 12px;">최종 메시지</p>
                        <p>AI 시대에는 "코딩을 잘하는 사람"이 아니라 <strong>"무엇을 만들어야 하는지 아는 사람"</strong>이 이깁니다.</p>
                        <p style="margin-top: 12px;">도구는 배우되 집착하지 말고, 기술은 익히되 본질을 잊지 마세요. 가장 중요한 것은 여전히 <strong>당신의 아이디어, 비전, 그리고 문제 해결 능력</strong>입니다.</p>
                    </div>
                </div>
            </section>

            <div class="divider"></div>

            <!-- Section: Resources -->
            <section id="learning" class="section">
                <div class="section-number">Resources</div>
                <h2 class="section-title">학습 리소스</h2>
                <p class="section-description">
                    더 깊이 배우기 위한 자료들입니다.
                </p>

                <h3>공식 문서</h3>
                <ul>
                    <li><strong>Cursor:</strong> cursor.com/docs</li>
                    <li><strong>Claude Code:</strong> docs.anthropic.com/en/docs/agents</li>
                    <li><strong>Cline:</strong> github.com/cline/cline</li>
                    <li><strong>Codex CLI:</strong> developers.openai.com/codex/cli</li>
                    <li><strong>Antigravity:</strong> antigravity.google</li>
                </ul>

                <h3>커뮤니티</h3>
                <ul>
                    <li>Cursor Discord 서버</li>
                    <li>Cline GitHub Discussions</li>
                    <li>Reddit r/cursor, r/ClaudeAI</li>
                    <li>YouTube 튜토리얼 채널</li>
                </ul>

                <div class="divider"></div>

                <div class="info-box highlight">
                    <h4>핵심 요약</h4>
                    <ul>
                        <li><strong>Model:</strong> AI의 두뇌 - Claude (코딩), Gemini (종합), Grok (감성), GPT (비용)</li>
                        <li><strong>Harness:</strong> Agent + Tools + Skills - Model이 똑똑해질수록 가벼워져야 함</li>
                        <li><strong>Pilot:</strong> 가장 중요 - 문제 분해, 실패 패턴 이해, 도메인 지식, 검증 능력</li>
                        <li><strong>현실:</strong> AI Slop 주의 - 이해하지 못하는 코드는 배포하지 마라</li>
                        <li><strong>미래:</strong> 아이디어 = 산출물 - 소프트웨어는 자산이 아니라 부채</li>
                        <li><strong>진화:</strong> Context Engineer로 발전 - 무엇을 만들지 아는 것이 핵심</li>
                    </ul>
                </div>

                <h3>마치며</h3>

                <p>AI 페어 프로그래밍은 이제 선택이 아닌 필수입니다. 빠르게 변하는 환경에서 경쟁력을 유지하려면 지금 바로 시작하는 것이 좋습니다.</p>

                <p>완벽하지 않아도 괜찮습니다. 작은 것부터 시도하고, 실패하면서 배우고, 점진적으로 익숙해지면 됩니다.</p>

                <p>중요한 것은 AI가 대신해주는 것이 아니라, AI와 함께 더 나은 코드를 만드는 것입니다. 그리고 더 중요한 것은 <strong>무엇을 만들 것인가</strong>에 대한 명확한 비전입니다.</p>

                <div style="text-align: center; margin-top: 60px; padding: 30px 0; border-top: 1px solid var(--border);">
                    <h2 style="font-size: 32px; margin-bottom: 12px; font-weight: 700;">
                        AI 페어 프로그래밍 가이드
                    </h2>
                    <p style="font-size: 15px; color: var(--text-muted);">
                        2025년 11월 22일 최신 업데이트
                    </p>
                </div>
            </section>
        </main>
    </div>

    <button class="back-to-top" id="backToTop">↑</button>

    <script>
        const navItems = document.querySelectorAll('.nav-item');
        const sections = document.querySelectorAll('.section');
        const backToTopBtn = document.getElementById('backToTop');

        function updateActiveNav() {
            let currentSection = '';
            sections.forEach(section => {
                const sectionTop = section.offsetTop;
                if (window.pageYOffset >= sectionTop - 100) {
                    currentSection = section.getAttribute('id');
                }
            });
            navItems.forEach(item => {
                item.classList.remove('active');
                if (item.getAttribute('href') === `#${currentSection}`) {
                    item.classList.add('active');
                }
            });
        }

        navItems.forEach(item => {
            item.addEventListener('click', (e) => {
                e.preventDefault();
                const targetId = item.getAttribute('href');
                const targetSection = document.querySelector(targetId);
                if (targetSection) {
                    targetSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
                }
            });
        });

        window.addEventListener('scroll', () => {
            updateActiveNav();
            if (window.pageYOffset > 300) {
                backToTopBtn.classList.add('visible');
            } else {
                backToTopBtn.classList.remove('visible');
            }
        });

        backToTopBtn.addEventListener('click', () => {
            window.scrollTo({ top: 0, behavior: 'smooth' });
        });

        updateActiveNav();
    </script>
</body>
</html>
